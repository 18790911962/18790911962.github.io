<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>酷炫3D 粒子圣诞树</title>
  <style>
    html,body{height:100%;margin:0;background:#060611;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    canvas{display:block;position:fixed;inset:0;width:100%;height:100%;background:linear-gradient(180deg,#05040a 0%,#071022 60%);}
    .ui{position:fixed;left:12px;top:12px;z-index:10;background:linear-gradient(180deg,#ffffff12,#ffffff06);backdrop-filter:blur(8px);padding:10px;border-radius:10px;border:1px solid #ffffff20}
    .ui button{margin:4px;padding:8px 10px;border-radius:8px;border:none;background:#ffd56e;color:#081028;cursor:pointer}
    .title{font-weight:700;margin-bottom:6px}
    .hint{opacity:.85;font-size:13px;margin-top:6px}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="ui">
    <div class="title">3D 粒子圣诞树</div>
    <div>
      <button id="toggleLights">切换彩灯</button>
      <button id="toggleSnow">切换雪花</button>
      <button id="reset">重置视角</button>
    </div>
    <div class="hint">拖拽旋转 · 滚轮缩放 · 点击彩灯闪烁</div>
  </div>
  <script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', {alpha: true});
  let W = innerWidth, H = innerHeight; function resize(){W=canvas.width=innerWidth;H=canvas.height=innerHeight}resize(); addEventListener('resize', resize);

  // offscreen particle texture (soft circle)
  const tex = document.createElement('canvas'); tex.width = tex.height = 64; const tctx = tex.getContext('2d');
  const g = tctx.createRadialGradient(32,32,2,32,32,32); g.addColorStop(0,'rgba(255,255,255,0.95)'); g.addColorStop(0.2,'rgba(255,240,220,0.9)'); g.addColorStop(0.45,'rgba(255,120,60,0.6)'); g.addColorStop(1,'rgba(0,0,0,0)'); tctx.fillStyle=g; tctx.fillRect(0,0,64,64);

  // tree particles (needles) and lights
  const particles = [];
  const lights = [];
  const snow = [];

  const TREE_HEIGHT = 340;
  const BASE_RADIUS = 180;
  const N = 1600;
  for(let i=0;i<N;i++){
    const u = Math.random(); // along height
    const y = u * TREE_HEIGHT; // 0..H
    const ringR = BASE_RADIUS * (1 - u) * (0.7 + 0.3*Math.random());
    const ang = Math.random()*Math.PI*2;
    const x = Math.cos(ang)*ringR + (Math.random()-0.5)*6;
    const z = Math.sin(ang)*ringR + (Math.random()-0.5)*6;
    const hue = 120 + Math.random()*30;
    particles.push({x,y,z,hue,sz:1+Math.random()*1.8});
    if(Math.random()<0.06){ // lights
      const hue2 = Math.random()*360;
      lights.push({x,y,z,h:hue2,phase:Math.random()*Math.PI*2,sz:2.5+Math.random()*3});
    }
  }

  // snow
  function spawnSnow(){ for(let i=0;i<220;i++){ snow.push({x:Math.random()*W,y:Math.random()*-H,z:Math.random()*400+200,r:1+Math.random()*2,spd:0.3+Math.random()*1}); } }
  spawnSnow();

  // camera / controls
  let camZ = 900; let rotY = 0.9, rotX = -0.2; let targetY = rotY, targetX = rotX; let zoom = 1.0;
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener('pointerdown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); });
  addEventListener('pointerup', e=>{ dragging=false; });
  addEventListener('pointermove', e=>{ if(!dragging) return; const dx=(e.clientX-lastX); const dy=(e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; targetY += dx*0.005; targetX += dy*0.005; });
  addEventListener('wheel', e=>{ zoom *= (1 - e.deltaY*0.001); zoom = Math.max(0.4,Math.min(2.2,zoom)); });

  // utilities: project 3D to screen
  function project(px,py,pz){ const cz = pz + camZ/zoom; const k = (camZ/zoom)/cz; const sx = W/2 + px * k; const sy = H*0.65 - py * k; return {x:sx,y:sy,k}; }

  let last = 0; let t = 0; let lightsOn = true; let snowOn = true;

  function draw(now){
    const dt = (now - last) * 0.001; last = now; t = now*0.001;
    // smooth camera
    rotY += (targetY - rotY) * 0.08; rotX += (targetX - rotX) * 0.08;

    // clear with slight alpha for motion trails
    ctx.clearRect(0,0,W,H);
    // soft background glow
    const bgGrad = ctx.createLinearGradient(0,0,0,H);
    bgGrad.addColorStop(0,'rgba(15,18,30,0.6)'); bgGrad.addColorStop(1,'rgba(6,8,16,0.9)');
    ctx.fillStyle = bgGrad; ctx.fillRect(0,0,W,H);

    // draw particles with additive blending for glow
    ctx.globalCompositeOperation = 'lighter';
    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);

    // draw needles (green particles)
    for(const p of particles){
      // rotate Y
      let rx = p.x * cosY + p.z * sinY;
      let rz = -p.x * sinY + p.z * cosY;
      // rotate X around X axis (affects y/z)
      let ry = p.y * cosX - rz * sinX;
      rz = p.y * sinX + rz * cosX;
      const pr = project(rx, ry, rz);
      if(pr.k <= 0) continue;
      const size = (p.sz * 8) * pr.k * (0.6 + (1-pr.k)*0.6);
      // gradient color
      const hue = p.hue;
      ctx.save(); ctx.globalAlpha = 0.85; ctx.translate(pr.x, pr.y); ctx.scale(size/64, size/64);
      // tint using globalComposite and draw texture tinted via fill
      ctx.drawImage(tex, -32, -32);
      ctx.restore();
    }

    // draw lights
    if(lightsOn){
      for(const l of lights){
        let rx = l.x * cosY + l.z * sinY; let rz = -l.x * sinY + l.z * cosY;
        let ry = l.y * cosX - rz * sinX; rz = l.y * sinX + rz * cosX;
        const pr = project(rx, ry, rz);
        if(pr.k <= 0) continue;
        const pulse = 0.6 + 0.4*Math.sin(t*6 + l.phase);
        const size = l.sz * 6 * pr.k * pulse;
        ctx.beginPath();
        const col = `hsl(${l.h},100%,60%)`;
        const g = ctx.createRadialGradient(pr.x,pr.y,0,pr.x,pr.y,size*1.4);
        g.addColorStop(0, `rgba(255,255,255,${0.95*pulse})`);
        g.addColorStop(0.16, `hsla(${l.h},100%,65%,${0.9*pulse})`);
        g.addColorStop(0.36, `hsla(${l.h},90%,55%,${0.35*pulse})`);
        g.addColorStop(1, `hsla(${l.h},80%,40%,0)`);
        ctx.fillStyle = g; ctx.fillRect(pr.x-size*1.8, pr.y-size*1.8, size*3.6, size*3.6);
      }
    }

    // tree outline: soft cone silhouette
    ctx.globalCompositeOperation = 'source-over';
    ctx.save(); ctx.globalAlpha = 0.08; ctx.fillStyle = '#000'; ctx.translate(0,0); ctx.beginPath();
    ctx.ellipse(W/2, H*0.65 - (TREE_HEIGHT*0.5)* (camZ/zoom)/(camZ/zoom+100), BASE_RADIUS*1.6, TREE_HEIGHT*0.55, 0, 0, Math.PI*2);
    ctx.fill(); ctx.restore();

    // top star
    const top3D = {x:0,y:TREE_HEIGHT+12,z:0};
    let rx = top3D.x * cosY + top3D.z * sinY; let rz = -top3D.x * sinY + top3D.z * cosY;
    let ry = top3D.y * cosX - rz * sinX; rz = top3D.y * sinX + rz * cosX;
    const top = project(rx,ry,rz);
    if(top.k>0){ drawStar(top.x, top.y, 22*top.k); }

    // snow
    if(snowOn){
      ctx.globalCompositeOperation = 'lighter';
      for(let s of snow){ s.y += s.spd + 30*dt; s.x += Math.sin((s.y+s.z)*0.002)*0.6; if(s.y>H+20){ s.y = -20; s.x = Math.random()*W; s.z = Math.random()*400+200 } ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill(); }
    }

    requestAnimationFrame(draw);
  }

  function drawStar(cx,cy,size){ ctx.save(); ctx.translate(cx,cy); ctx.rotate(t*0.6); ctx.globalCompositeOperation='lighter';
    const g = ctx.createRadialGradient(0,0,0,0,0,size*1.2); g.addColorStop(0,'#fff'); g.addColorStop(0.2,'#fff8'); g.addColorStop(0.5,'#ffd56e'); g.addColorStop(1,'rgba(255,210,120,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,size*0.9,0,Math.PI*2); ctx.fill();
    // simple rays
    ctx.strokeStyle='rgba(255,240,200,0.9)'; ctx.lineWidth = Math.max(1, size*0.08);
    for(let i=0;i<8;i++){ ctx.rotate(Math.PI*2/8); ctx.beginPath(); ctx.moveTo(0,size*0.9); ctx.lineTo(0,size*1.8); ctx.stroke(); }
    ctx.restore(); }

  // toggle buttons
  document.getElementById('toggleLights').addEventListener('click', ()=>{ lightsOn = !lightsOn; });
  document.getElementById('toggleSnow').addEventListener('click', ()=>{ snowOn = !snowOn; });
  document.getElementById('reset').addEventListener('click', ()=>{ targetY = 0.9; targetX = -0.2; zoom = 1; });

  // click to create temporary sparkle
  canvas.addEventListener('click', e=>{
    // find nearest light and boost its phase to create flash
    let minD=1e9, idx=-1; for(let i=0;i<lights.length;i++){ const l=lights[i]; const dx = (l.x - ((e.clientX-W/2)*(1/(camZ/zoom)))); const dy = (l.y - ((H*0.65 - e.clientY)*(1/(camZ/zoom)))); const d = Math.hypot(dx,dy); if(d<minD){minD=d;idx=i}} if(idx>=0){ lights[idx].phase += Math.PI*2; }
  });

  requestAnimationFrame(draw);
  </script>
</body>
</html>

